#! /usr/bin/env python
# -*- encoding:utf-8 -*-

"""
Usage:
   lys deploy-listener <event> <function> (<regexp> | -f <field> -c <condition> -v <value>) [-l <listener> -w <webhook>]
   lys destroy-listener [<function>]
   lys start-server
   lys stop-server

Options:
-f --field=<field>         : the transaction field to be checked by the node
-c --condition=<condition> : the condition operator used to check the field
-v --value=<value>         : the value triggering the webhook
-l --listener=<listener>   : the peer receiving whebhook POST request
-w --webhook=<webhook>     : the peer registering the webhook

Subcommands:
   deploy-listener  : link a webhook <event> with a python <function> 
   destroy-listener : unlink webhook <event> from python <function>
   start-server     : start/restart listener server
   stop-server      : stop listener server
"""

import os
import sys
import docopt

# add lystener path if not installed via pip tool
sys.path.append(os.path.abspath(os.path.expanduser("~/ark-listener")))
import lystener
from lystener import rest, logMsg, loadJson, dumpJson, chooseItem


def start_server(args={}, **options):
	os.system("""
if [ "$(pm2 id lystener-server) " = "[] " ]; then
	cd %(abspath)s
	pm2 start app.json
else
	pm2 restart lystener-server
fi
""" % {"abspath": os.path.join(lystener.__path__[0], "..")}
)


def stop_server(args={}, **options):
	os.system("""
if [ "$(pm2 id lystener-server) " != "[] " ]; then
	cd %(abspath)s
	pm2 stop lystener-server
fi
""" % {"abspath": os.path.join(lystener.__path__[0], "..")}
)


def deploy_listener(args={}, **options):
	"""
	link ark blockchain event to a python function.
	"""

	# function should be a string : module_name.function_name
	function = args["<function>"]
	json_name = "%s.json" % function
	# build default peers
	webhook_peer = options.get("webhook", "%(protocol)s://%(ip)s:%(port)s" % rest.WEBHOOK_PEER)
	listener_peer = options.get("listener", "%(protocol)s://%(ip)s:%(port)s" % rest.LISTENER_PEER)

	# compute listener condition
	# if only a regexp is givent compute condition on vendorField
	if "<regexp>" in args:
		condition = {
			"key": "vendorField",
			"condition": "regexp",
			"value": args["<regexp>"]
		}
	# else create a condition.
	# Ark webhook api will manage condition errors
	elif len(options):
		condition = {
			"field": options["field"],
			"condition": options["condition"],
			"value": options["value"]
		}

	# load webhook configuration if already set
	webhook = loadJson(json_name)
	# loadJson returns void dict if json_name not found,
	# the if clause bellow will be true then
	if not webhook.get("token", False):
		# create the webhook
		req = rest.POST.api.webhooks(
			event=args["<event>"],
			peer=webhook_peer,
			target=listener_peer +"/"+ "/".join(function.split(".")),
			conditions=[condition]
		)
		# parse request result
		if not req.get("error", False):
			webhook = req["data"]
			# save the used peer to be able to delete it later
			webhook["peer"] = webhook_peer
			# save webhook configuration in JSON folder
			dumpJson(webhook, json_name)
			logMsg("%s webhook set" % function)
		else:
			logMsg("%r" % req)
			logMsg("%s webhook not set" % function)
	else:
		logMsg("webhook already set for %s" % function)


def destroy_listener(args={}, **options):
	"""
	unlink ark blockchain event from a python function.
	"""

	function = args.get("<function>", False)
	if not function:
		logMsg("manual selection not implemented yet")
		listeners = [name.replace(".json", "") for name in os.listdir(lystener.JSON) if name.endswith(".json")]
		choice = chooseItem("Select listener to destroy:", *listeners)
		if not choice: return
		else: args["<function>"] = choice

	json_name = "%s.json" % args["<function>"]
	# load webhook configuration
	webhook = loadJson(json_name)
	# condition bellow checks if webhook configurations is found
	if webhook.get("peer", False):
		# delete webhook usong its id and parent peer
		rest.DELETE.api.webhooks("%s"%webhook["id"], peer=webhook["peer"])
		# delete the webhook configuration
		os.remove(os.path.join(lystener.JSON, json_name))
		logMsg("%s webhook destroyed" % function)
	else:
		logMsg("%s webhook not found" % function)


# command line execution
########################
if __name__ == "__main__":

	FILTER = {
		"--condition": lambda value: value,
		"--field":     lambda value: value,
		"--listener":  lambda value: value,
		"--value":     lambda value: value,
		"--webhook":   lambda value: value,
		"<regexp>":    lambda value: getattr(value, "pattern", value)
	}

	# will get the first argument which is neither a value neither an option
	def getAction(args):
		for action in [k for k in args if k[0] not in ["-", "<"]]:
			if args[action] == True:
				return action
		return False

	# will rename --multi-word-option to multi_word_option
	def getOptions(args):
		options = {}
		for option,value in [(k,v) for k,v in args.items() if k.startswith("--") and v != None]:
			options[option[2:].replace("-", "_")] = value
		return dict((k,v) for k,v in options.items() if v != None)

	# see http://docopt.org
	args = docopt.docopt(__doc__, argv=sys.argv[1:])
	for key,cast in [(k,c) for k,c in FILTER.items() if k in args]:
		args[key] = cast(args[key])

	action = getAction(args)
	options = getOptions(args)

	if action:
		# rename multi-word-action to multi_word_action
		func = getattr(sys.modules[__name__], action.replace("-", "_"))
		if callable(func):
			func(args, **options)
