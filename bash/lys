#! /usr/bin/env python
# -*- encoding:utf-8 -*-

"""
Usage:
   lys deploy-listener <event> <function> (<regexp> | -f <field> -c <condition> -v <value> | -m <data>) [-l <listener> -w <webhook>]
   lys destroy-listener
   lys start-listening [-i <ip> -p <port>]
   lys stop-listening
   lys public-ip

Options:
-f --field=<field>         : the transaction field to be checked by the node
-c --condition=<condition> : the condition operator used to check the field
-v --value=<value>         : the value triggering the webhook
-m --multiple=<data>       : coma-separated list of key|operator|value terms
-l --listener=<listener>   : the peer receiving whebhook POST request
-w --webhook=<webhook>     : the peer registering the webhook
-i --ip=<ip>               : the ip used for listening srv   [default: 0.0.0.0]
-p --port=<port>           : the port used for listening srv [default: 5001]

Subcommands:
   deploy-listener  : link a webhook <event> with a python <function> 
   destroy-listener : unlink webhook <event> from python <function>
   start-listening  : start/restart listener srv
   stop-listening   : stop listener srv
   public-ip        : get public ip
"""
# -e --endpoints=<endpoints> : the end points where to broadcast event (UNTESTED),  -e <endpoints>


import os
import re
import sys
import docopt

# add git installation
sys.path.append(os.path.abspath(os.path.expanduser("~/ark-listener")))
# add parent path if executed from git structure
sys.path.append(os.path.join(os.path.dirname(__file__), ".."))

import lystener
from lystener import rest


def start_pm2_app(appname, folder="?"):
	os.system('''
if echo "$(pm2 id %(appname)s | tail -n 1)" | grep -qE "\[\]"; then
	cd %(pm2_app_folder)s
	pm2 start app.json
else
	echo "(re)starting %(appname)s..."
    pm2 restart %(appname)s -s
fi
''' % {
	"appname": appname,
	"pm2_app_folder": os.path.dirname(lystener.ROOT) if not os.path.isdir(folder) else folder
})


def stop_pm2_app(appname):
	os.system('''
if ! echo "$(pm2 id %(appname)s | tail -n 1)" | grep -qE "\[\]"; then
	echo stoping %(appname)s...
    pm2 stop %(appname)s -s
fi
''' % {"appname": appname}
)

def public_ip(args={}, **options):
	sys.stdout.write("%s\n" % lystener.getPublicIp())
	sys.stdout.flush()


def start_listening(args={}, **options):
	# persistent options effect modifying the pm2 app.json configuration
	pm2_app_folder = os.path.abspath(os.path.dirname(lystener.__path__[0]))
	app = lystener.loadJson("srv.json", folder=pm2_app_folder)
	rest.LISTENER_PEER["port"] = options["port"]
	rest.LISTENER_PEER["ip"] = options["ip"]
	app["apps"][0]["args"] = "%s" % options["port"]
	appname = app["apps"][0]["name"] = "lys-srv"
	lystener.dumpJson(app, "srv.json", folder=pm2_app_folder)
	# execute pm2 command lines
	start_pm2_app(appname, folder=pm2_app_folder)


def stop_listening(args={}, **options):
	stop_pm2_app("lys-srv")


def deploy_listener(args={}, **options):
	"""
	link blockchain event to a python function.
	"""

	function = args.get("<function>", options.get("function", False))
	regexp = args.get("<regexp>", options.get("regexp", False))
	event = args.get("<event>", options.get("event", False))
	# json_name = "%s.json" % function

	# build peers and target url
	webhook_peer = options.get("webhook", "%(scheme)s://%(ip)s:%(port)s" % rest.WEBHOOK_PEER)
	listener_peer = options.get("listener", "%(scheme)s://%(ip)s:%(port)s" % rest.LISTENER_PEER)
	target_url = listener_peer +"/"+ function.replace(".", "/")

	# compute listener condition
	# if only a regexp is givent compute condition on vendorField
	if regexp:
		condition = {
			"key": "vendorField",
			"condition": "regexp",
			"value": args["<regexp>"]
		}
	# else create a condition.
	# Ark webhook api will manage condition errors
	elif len(options):
		try: value = int(value)
		except: value = options["value"]
		condition = {
			"key": options["field"],
			"condition": options["condition"],
			"value": value
		}
	
	# create the webhook
	req = rest.POST.api.webhooks(event=event, peer=webhook_peer, target=target_url, conditions=[condition])
	# parse request result if no error messages
	if not req.get("except", False):
		webhook = req["data"]
		# save the used peer to be able to delete it later
		webhook["peer"] = webhook_peer
		# save webhook configuration in JSON folder
		lystener.dumpJson(webhook, webhook["token"][:32] + ".json")
		lystener.logMsg("%s webhook set" % function)
	else:
		lystener.logMsg("%r" % req)
		lystener.logMsg("%s webhook not set" % function)


def destroy_listener(args={}, **options):
	"""
	unlink blockchain event from a id list.
	"""

	listeners = [name.replace(".json", "") for name in os.listdir(lystener.JSON) if name.endswith(".json")]
	id_ = lystener.chooseItem("Select listener to destroy:", *listeners)
	if not id_: return

	json_name = "%s.json" % id_
	# load webhook configuration
	webhook = lystener.loadJson(json_name)
	# condition bellow checks if webhook configurations is found
	if webhook.get("peer", False):
		# delete webhook using its id and parent peer
		rest.DELETE.api.webhooks("%s"%webhook["id"], peer=webhook["peer"])
		# delete the webhook configuration
		os.remove(os.path.join(lystener.JSON, json_name))
		lystener.logMsg("%s webhook destroyed" % id_)
	else:
		lystener.logMsg("%s webhook not found" % id_)


# command line execution
########################
if __name__ == "__main__":

	FILTER = {
		"--condition": lambda value: value,
		"--field":     lambda value: value,
		"--listener":  lambda value: value,
		"--value":     lambda value: value,
		"--webhook":   lambda value: value,
		"<regexp>":    lambda value: getattr(value, "pattern", value)
	}

	# will get the first argument which is neither a value neither an option
	def getAction(args):
		for action in [k for k in args if k[0] not in ["-", "<"]]:
			if args[action] == True:
				return action
		return False

	# will rename --multi-word-option to multi_word_option
	def getOptions(args):
		options = {}
		for option,value in [(k,v) for k,v in args.items() if k.startswith("--") and v != None]:
			options[option[2:].replace("-", "_")] = value
		return dict((k,v) for k,v in options.items() if v != None)

	# see http://docopt.org
	args = docopt.docopt(__doc__, argv=sys.argv[1:])
	for key,cast in [(k,c) for k,c in FILTER.items() if k in args]:
		args[key] = cast(args[key])

	action = getAction(args)
	options = getOptions(args)

	if action:
		# rename multi-word-action to multi_word_action
		func = getattr(sys.modules[__name__], action.replace("-", "_"))
		if callable(func):
			func(args, **options)
